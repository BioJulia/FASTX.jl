var documenterSearchIndex = {"docs":
[{"location":"fastq/","page":"FASTQ","title":"FASTQ","text":"CurrentModule = FASTX\nDocTestSetup = quote\n    using FASTX\nend","category":"page"},{"location":"fastq/#FASTQ-formatted-files","page":"FASTQ","title":"FASTQ formatted files","text":"","category":"section"},{"location":"fastq/","page":"FASTQ","title":"FASTQ","text":"NB: First read the overview in the sidebar","category":"page"},{"location":"fastq/","page":"FASTQ","title":"FASTQ","text":"FASTQ is a text-based file format for representing DNA sequences along with qualities for each base. A FASTQ file stores a list of sequence records in the following format:","category":"page"},{"location":"fastq/","page":"FASTQ","title":"FASTQ","text":"The template of a sequence record is:","category":"page"},{"location":"fastq/","page":"FASTQ","title":"FASTQ","text":"@{description}\n{sequence}\n+{description}?\n{qualities}","category":"page"},{"location":"fastq/","page":"FASTQ","title":"FASTQ","text":"Where the \"identifier\" is the first part of the description up to the first whitespace (or the entire description if there is no whitespace)","category":"page"},{"location":"fastq/","page":"FASTQ","title":"FASTQ","text":"The description may optionally be present on the third line, and if so, must be identical to the description on the first line.","category":"page"},{"location":"fastq/","page":"FASTQ","title":"FASTQ","text":"Here is an example of one record from a FASTQ file:","category":"page"},{"location":"fastq/","page":"FASTQ","title":"FASTQ","text":"@FSRRS4401BE7HA\ntcagTTAAGATGGGAT\n+\n###EEEEEEEEE##E#","category":"page"},{"location":"fastq/#The-FASTQRecord","page":"FASTQ","title":"The FASTQRecord","text":"","category":"section"},{"location":"fastq/","page":"FASTQ","title":"FASTQ","text":"FASTQRecords optionally have the description repeated on the third line. This can be toggled with quality_header!(::Record, ::Bool):","category":"page"},{"location":"fastq/","page":"FASTQ","title":"FASTQ","text":"julia> record = parse(FASTQRecord, \"@ILL01\\nCCCGC\\n+\\nKM[^d\");\n\njulia> print(record)\n@ILL01\nCCCGC\n+\nKM[^d\n\njulia> quality_header!(record, true); print(record)\n@ILL01\nCCCGC\n+ILL01\nKM[^d","category":"page"},{"location":"fastq/","page":"FASTQ","title":"FASTQ","text":"FASTQ.Record","category":"page"},{"location":"fastq/#FASTX.FASTQ.Record","page":"FASTQ","title":"FASTX.FASTQ.Record","text":"FASTQ.Record\n\nMutable struct representing a FASTQ record as parsed from a FASTQ file. The content of the record can be queried with the following functions: identifier, description, sequence, quality FASTQ records are un-typed, i.e. they are agnostic to what kind of data they contain.\n\nSee also: FASTQ.Reader, FASTQ.Writer\n\nExamples\n\njulia> rec = parse(FASTQRecord, \"@ill r1\\nGGC\\n+\\njjk\");\n\njulia> identifier(rec)\n\"ill\"\n\njulia> description(rec)\n\"ill r1\"\n\njulia> sequence(rec)\n\"GGC\"\n\njulia> show(collect(quality_scores(rec)))\nInt8[73, 73, 74]\n\njulia> typeof(description(rec)) == typeof(sequence(rec)) <: AbstractString\ntrue\n\n\n\n\n\n","category":"type"},{"location":"fastq/#Qualities","page":"FASTQ","title":"Qualities","text":"","category":"section"},{"location":"fastq/","page":"FASTQ","title":"FASTQ","text":"Unlike FASTARecords, a FASTQRecord contain quality scores, see the example above.","category":"page"},{"location":"fastq/","page":"FASTQ","title":"FASTQ","text":"The quality string can be obtained using the quality method:","category":"page"},{"location":"fastq/","page":"FASTQ","title":"FASTQ","text":"julia> record = parse(FASTQRecord, \"@ILL01\\nCCCGC\\n+\\nKM[^d\");\n\njulia> quality(record)\n\"KM[^d\"","category":"page"},{"location":"fastq/","page":"FASTQ","title":"FASTQ","text":"Qualities are numerical values that are encoded by ASCII characters. Unfortunately, multiple encoding schemes exist, although PHRED+33 is the most common. The scores can be obtained using the quality_scores function, which returns an iterator of PHRED+33 scores:","category":"page"},{"location":"fastq/","page":"FASTQ","title":"FASTQ","text":"julia> collect(quality_scores(record))\n5-element Vector{Int8}:\n 42\n 44\n 58\n 61\n 67","category":"page"},{"location":"fastq/","page":"FASTQ","title":"FASTQ","text":"If you want to decode the qualities using another scheme, you can use one of the predefined QualityEncoding objects. For example, Illumina v 1.3 used PHRED+64:","category":"page"},{"location":"fastq/","page":"FASTQ","title":"FASTQ","text":"julia> collect(quality_scores(record, FASTQ.ILLUMINA13_QUAL_ENCODING))\n5-element Vector{Int8}:\n 11\n 13\n 27\n 30\n 36","category":"page"},{"location":"fastq/","page":"FASTQ","title":"FASTQ","text":"Alternatively, quality_scores accept a name of the known quality encodings:","category":"page"},{"location":"fastq/","page":"FASTQ","title":"FASTQ","text":"julia> (collect(quality_scores(record, FASTQ.ILLUMINA13_QUAL_ENCODING)) ==\n        collect(quality_scores(record, :illumina13)))\ntrue","category":"page"},{"location":"fastq/","page":"FASTQ","title":"FASTQ","text":"Lastly, you can create your own:","category":"page"},{"location":"fastq/","page":"FASTQ","title":"FASTQ","text":"QualityEncoding","category":"page"},{"location":"fastq/#FASTX.FASTQ.QualityEncoding","page":"FASTQ","title":"FASTX.FASTQ.QualityEncoding","text":"QualityEncoding(range::StepRange{Char}, offset::Integer)\n\nFASTQ quality encoding scheme. QualityEncoding objects are used to interpret the quality scores of FASTQ records. range is a range of allowed ASCII chars in the encoding, e.g. '!':'~' for the most common encoding scheme. The offset is the ASCII offset, i.e. a character with ASCII value x encodes the value x - offset.\n\nSee also: quality_scores\n\nExamples\n\njulia> read = parse(FASTQ.Record, \"@hdr\\nAGA\\n+\\nabc\");\n\njulia> qe = QualityEncoding('a':'z', 16); # hypothetical encoding\n\njulia> collect(quality_scores(read, qe)) == [Int8(i) - 16 for i in \"abc\"]\ntrue\n\n\n\n\n\n","category":"type"},{"location":"fastq/#Reference:","page":"FASTQ","title":"Reference:","text":"","category":"section"},{"location":"fastq/","page":"FASTQ","title":"FASTQ","text":"quality\nquality_scores\nquality_header!","category":"page"},{"location":"fastq/#FASTX.FASTQ.quality","page":"FASTQ","title":"FASTX.FASTQ.quality","text":"quality([T::Type{String, StringView}], record::FASTQ.Record, [part::UnitRange])\n\nGet the ASCII quality of record at positions part as type T. If not passed, T defaults to StringView. If not passed, part defaults to the entire quality string.\n\nExamples\n\njulia> rec = parse(FASTQ.Record, \"@hdr\\nUAGUCU\\n+\\nCCDFFG\");\n\njulia> qual = quality(rec)\n\"CCDFFG\"\n\njulia> qual isa AbstractString\ntrue\n\n\n\n\n\n","category":"function"},{"location":"fastq/#FASTX.FASTQ.quality_scores","page":"FASTQ","title":"FASTX.FASTQ.quality_scores","text":"quality_scores(record::FASTQ.Record, [encoding::QualityEncoding], [part::UnitRange])\n\nGet an iterator of PHRED base quality scores of record at positions part. This iterator is corrupted if the record is mutated. By default, part is the whole sequence. By default, the encoding is PHRED33 Sanger encoding, but may be specified with a QualityEncoding object\n\n\n\n\n\nquality(record::Record, encoding_name::Symbol, [part::UnitRange])::Vector{UInt8}\n\nGet an iterator of base quality of the slice part of record's quality.\n\nThe encoding_name can be either :sanger, :solexa, :illumina13, :illumina15, or :illumina18.\n\n\n\n\n\n","category":"function"},{"location":"fastq/#FASTX.FASTQ.quality_header!","page":"FASTQ","title":"FASTX.FASTQ.quality_header!","text":"quality_header!(record::Record, x::Bool)\n\nSet whether the record repeats its header on the quality comment line, i.e. the line with +.\n\nExamples\n\njulia> record = parse(FASTQ.Record, \"@A B\\nT\\n+\\nJ\");\n\njulia> string(record)\n\"@A B\\nT\\n+\\nJ\"\n\njulia> quality_header!(record, true);\n\njulia> string(record)\n\"@A B\\nT\\n+A B\\nJ\"\n\n\n\n\n\n","category":"function"},{"location":"fastq/#FASTQReader-and-FASTQWriter","page":"FASTQ","title":"FASTQReader and FASTQWriter","text":"","category":"section"},{"location":"fastq/","page":"FASTQ","title":"FASTQ","text":"FASTQWriter can optionally be passed the keyword quality_header to control whether or not to print the description on the third line (the one with +). By default this is nothing, meaning that it will print the second header, if present in the record itself.","category":"page"},{"location":"fastq/","page":"FASTQ","title":"FASTQ","text":"If set to a Bool value, the Writer will override the Records, without changing the records themselves.","category":"page"},{"location":"fastq/#Reference:-2","page":"FASTQ","title":"Reference:","text":"","category":"section"},{"location":"fastq/","page":"FASTQ","title":"FASTQ","text":"FASTQ.Reader\nFASTQ.Writer\nvalidate_fastq","category":"page"},{"location":"fastq/#FASTX.FASTQ.Reader","page":"FASTQ","title":"FASTX.FASTQ.Reader","text":"FASTQ.Reader(input::IO; copy::Bool=true)\n\nCreate a buffered data reader of the FASTQ file format. The reader is a BioGenerics.IO.AbstractReader, a stateful iterator of FASTQ.Record. Readers take ownership of the underlying IO. Mutating or closing the underlying IO not using the reader is undefined behaviour. Closing the Reader also closes the underlying IO.\n\nSee more examples in the FASTX documentation.\n\nSee also: FASTQ.Record, FASTQ.Writer\n\nArguments\n\ninput: data source\ncopy::Bool: iterating returns fresh copies instead of the same Record. Set to false for improved performance, but be wary that iterating mutates records.\n\nExamples\n\njulia> rdr = FASTQReader(IOBuffer(\"@readname\\nGGCC\\n+\\njk;]\"));\n\njulia> record = first(rdr); close(rdr);\n\njulia> identifier(record)\n\"readname\"\n\njulia> sequence(record)\n\"GGCC\"\n\njulia> show(collect(quality_scores(record))) # phred 33 encoding by default\nInt8[73, 74, 26, 60]\n\n\n\n\n\n","category":"type"},{"location":"fastq/#FASTX.FASTQ.Writer","page":"FASTQ","title":"FASTX.FASTQ.Writer","text":"FASTQ.Writer(output::IO; quality_header::Union{Nothing, Bool}=nothing)\n\nCreate a data writer of the FASTQ file format. The writer is a BioGenerics.IO.AbstractWriter. Writers take ownership of the underlying IO. Mutating or closing the underlying IO not using the writer is undefined behaviour. Closing the writer also closes the underlying IO.\n\nSee more examples in the FASTX documentation.\n\nSee also: FASTQ.Record, FASTQ.Reader\n\nArguments\n\noutput: Data sink to write to\nquality_header: Whether to print second header on the + line. If nothing (default), check the individual Record objects for whether they contain a second header.\n\nExamples\n\njulia> FASTQ.Writer(open(\"some_file.fq\", \"w\")) do writer\n    write(writer, record) # a FASTQ.Record\nend\n\n\n\n\n\n","category":"type"},{"location":"fastq/#FASTX.FASTQ.validate_fastq","page":"FASTQ","title":"FASTX.FASTQ.validate_fastq","text":"validate_fastq(io::IO) >: Nothing\n\nCheck if io is a valid FASTQ file. Return nothing if it is, and an instance of another type if not.\n\nExamples\n\njulia> validate_fastq(IOBuffer(\"@i1 r1\\nuuag\\n+\\nHJKI\")) === nothing\ntrue\n\njulia> validate_fastq(IOBuffer(\"@i1 r1\\nu;ag\\n+\\nHJKI\")) === nothing\nfalse\n\n\n\n\n\n","category":"function"},{"location":"fai/","page":"FAI","title":"FAI","text":"CurrentModule = FASTX\nDocTestSetup = quote\n    using FASTX\nend","category":"page"},{"location":"fai/#FASTA-index-(FAI-files)","page":"FAI","title":"FASTA index (FAI files)","text":"","category":"section"},{"location":"fai/","page":"FAI","title":"FAI","text":"FASTX.jl supports FASTA index (FAI) files. When a FASTA file is indexed with a FAI file, one can seek records by their name, or extract parts of records easily.","category":"page"},{"location":"fai/","page":"FAI","title":"FAI","text":"See the FAI specifcation here: http://www.htslib.org/doc/faidx.html","category":"page"},{"location":"fai/#Making-an-Index","page":"FAI","title":"Making an Index","text":"","category":"section"},{"location":"fai/","page":"FAI","title":"FAI","text":"A FASTA index (of type Index) can be constructed from an IO object representing a FAI file:","category":"page"},{"location":"fai/","page":"FAI","title":"FAI","text":"julia> io = IOBuffer(\"seqname\\t9\\t2\\t6\\t8\");\n\njulia> Index(io) isa Index\ntrue","category":"page"},{"location":"fai/","page":"FAI","title":"FAI","text":"Or from a path representing a FAI file:","category":"page"},{"location":"fai/","page":"FAI","title":"FAI","text":"julia> Index(\"/path/to/file.fai\")","category":"page"},{"location":"fai/","page":"FAI","title":"FAI","text":"Alternatively, a FASTA file can be indexed to produce an Index using faidx.","category":"page"},{"location":"fai/","page":"FAI","title":"FAI","text":"julia> faidx(IOBuffer(\">abc\\nTAGA\\nTA\"))\nIndex:\n  abc\t6\t5\t4\t5","category":"page"},{"location":"fai/","page":"FAI","title":"FAI","text":"Alternatively, a FASTA file can be indexed, and the index immediately written to a FAI file, by passing an AbstractString to faidx:","category":"page"},{"location":"fai/","page":"FAI","title":"FAI","text":"julia> ispath(\"/path/to/fasta.fna.fai\")\nfalse\n\njulia> faidx(\"/path/to/fasta.fna\");\n\njulia> ispath(\"/path/to/fasta.fna.fai\")\ntrue","category":"page"},{"location":"fai/","page":"FAI","title":"FAI","text":"Note that the restrictions on FASTA files for indexing are stricter than Julia's FASTA parser, so not all FASTA files that can be read can be indexed:","category":"page"},{"location":"fai/","page":"FAI","title":"FAI","text":"julia> str = \">\\0\\n\\0\";\n\njulia> first(FASTAReader(IOBuffer(str))) isa FASTARecord\ntrue\n\njulia> Index(IOBuffer(str))\nERROR\n[...]","category":"page"},{"location":"fai/#Attaching-an-Index-to-a-Reader","page":"FAI","title":"Attaching an Index to a Reader","text":"","category":"section"},{"location":"fai/","page":"FAI","title":"FAI","text":"When opening a FASTA.Reader, you can attach an Index by passing the index keyword. You can either pass an Index directly, or else an IO, in which case an Index will be parsed from the IO, or an AbstractString that will be interpreted as a path to a FAI file:","category":"page"},{"location":"fai/","page":"FAI","title":"FAI","text":"julia> str = \">abc\\nTAG\\nTA\";\n\njulia> idx = faidx(IOBuffer(str));\n\njulia> rdr = FASTAReader(IOBuffer(str), index=idx);","category":"page"},{"location":"fai/","page":"FAI","title":"FAI","text":"You can also add a index to an existing reader using the index! function:","category":"page"},{"location":"fai/","page":"FAI","title":"FAI","text":"index!","category":"page"},{"location":"fai/#FASTX.FASTA.index!","page":"FAI","title":"FASTX.FASTA.index!","text":"index!(r::FASTA.Reader, ind::Union{Nothing, Index, IO, AbstractString})\n\nSet the index of r, and return r. If ind isa Union{Nothing, Index}, directly set the index to ind. If ind isa IO, parse the index from the FAI-formatted IO first. If ind isa AbstractString, treat it as the path to a FAI file to parse.\n\nSee also: Index, FASTA.Reader\n\n\n\n\n\n","category":"function"},{"location":"fai/#Seeking-using-an-Index","page":"FAI","title":"Seeking using an Index","text":"","category":"section"},{"location":"fai/","page":"FAI","title":"FAI","text":"With an Index attached to a Reader, you can do the following operation in O(1) time. In these examples, we will use the following FASTA file:","category":"page"},{"location":"fai/","page":"FAI","title":"FAI","text":">seq1 sequence\nTAGAAAGCAA\nTTAAAC\n>seq2 sequence\nAACGG\nUUGC","category":"page"},{"location":"fai/","page":"FAI","title":"FAI","text":"DocTestSetup = quote\nusing FASTX\n\ndata = \"\"\">seq1 sequence\nTAGAAAGCAA\nTTAAAC\n>seq2 sequence\nAACGG\nUUGC\n\"\"\"\n\nreader = FASTA.Reader(IOBuffer(data), index=faidx(IOBuffer(data)))\n\nend","category":"page"},{"location":"fai/","page":"FAI","title":"FAI","text":"Seek to a Record using its identifier:","category":"page"},{"location":"fai/","page":"FAI","title":"FAI","text":"julia> seekrecord(reader, \"seq2\");\n\njulia> record = first(reader); sequence(record)\n\"AACGGUUGC\"","category":"page"},{"location":"fai/","page":"FAI","title":"FAI","text":"Directly extract a record using its identifier","category":"page"},{"location":"fai/","page":"FAI","title":"FAI","text":"julia> record = reader[\"seq1\"];\n\njulia> description(record)\n\"seq1 sequence\"","category":"page"},{"location":"fai/","page":"FAI","title":"FAI","text":"Extract a sequence directly without loading the whole record into memory. This is useful for huge sequences like chromosomes","category":"page"},{"location":"fai/","page":"FAI","title":"FAI","text":"julia> extract(reader, \"seq1\", 3:5)\n\"GAA\"","category":"page"},{"location":"fai/","page":"FAI","title":"FAI","text":"DocTestSetup = nothing","category":"page"},{"location":"fai/","page":"FAI","title":"FAI","text":"FASTX.jl does not yet support indexing FASTQ files.","category":"page"},{"location":"fai/#Reference:","page":"FAI","title":"Reference:","text":"","category":"section"},{"location":"fai/","page":"FAI","title":"FAI","text":"faidx\nseekrecord\nextract\nIndex","category":"page"},{"location":"fai/#FASTX.FASTA.faidx","page":"FAI","title":"FASTX.FASTA.faidx","text":"faidx(io::IO)::Index\n\nRead a FASTA.Index from io.\n\nSee also: Index\n\nExamples\n\njulia> ind = faidx(IOBuffer(\">ab\\nTA\\nT\\n>x y\\nGAG\\nGA\"))\nIndex:\n  ab\t3\t4\t2\t3\n  x\t5\t14\t3\t4\n\n\n\n\n\nfaidx(fnapath::AbstractString, [idxpath::AbstractString], check=true)\n\nIndex FASTA path at fnapath and write index to idxpath. If idxpath is not given, default to same name as fnapath * \".fai\". If check, throw an error if the output file already exists\n\nSee also: Index\n\n\n\n\n\n","category":"function"},{"location":"fai/#FASTX.FASTA.seekrecord","page":"FAI","title":"FASTX.FASTA.seekrecord","text":"seekrecord(reader::FASTAReader, i::Union{AbstractString, Integer})\n\nSeek Reader to the i'th record. The next iterated record with be the i'th record. i can be the identifier of a sequence, or the 1-based record number in the Index.\n\nThe Reader needs to be indexed for this to work.\n\n\n\n\n\n","category":"function"},{"location":"fai/#FASTX.FASTA.extract","page":"FAI","title":"FASTX.FASTA.extract","text":"extract(reader::Reader, name::AbstractString, range::Union{Nothing, UnitRange})\n\nExtract a subsequence given by index range from the sequence named in a Reader with an index. Returns a String. If range is nothing (the default value), return the entire sequence.\n\n\n\n\n\n","category":"function"},{"location":"fai/#FASTX.FASTA.Index","page":"FAI","title":"FASTX.FASTA.Index","text":"Index(src::Union{IO, AbstractString})\n\nFASTA index object, which allows constant-time seeking of FASTA files by name. The index is assumed to be in FAI format.\n\nNotable methods:\n\nIndex(::Union{IO, AbstractString}): Read FAI file from IO or file at path\nwrite(::IO, ::Index): Write index in FAI format\nfaidx(::IO)::Index: Index FASTA file\nseekrecord(::Reader, ::AbstractString): Go to position of seq\nextract(::Reader, ::AbstractString): Extract part of sequence\n\nNote that the FAI specs are stricter than FASTX.jl's definition of FASTA, such that some valid FASTA records may not be indexable. See the specs at: http://www.htslib.org/doc/faidx.html\n\nSee also: FASTA.Reader\n\nExamples\n\njulia> src = IOBuffer(\"seqname\\t9\\t14\\t6\\t8\\nA\\t1\\t3\\t1\\t2\");\n\njulia> fna = IOBuffer(\">A\\nG\\n>seqname\\nACGTAC\\r\\nTTG\");\n\njulia> rdr = FASTA.Reader(fna; index=src);\n\njulia> seekrecord(rdr, \"seqname\");\n\njulia> sequence(String, first(rdr))\n\"ACGTACTTG\"\n\n\n\n\n\n","category":"type"},{"location":"fasta/","page":"FASTA","title":"FASTA","text":"CurrentModule = FASTX\nDocTestSetup = quote\n    using FASTX\nend","category":"page"},{"location":"fasta/#FASTA-formatted-files","page":"FASTA","title":"FASTA formatted files","text":"","category":"section"},{"location":"fasta/","page":"FASTA","title":"FASTA","text":"NB: First read the overview in the sidebar","category":"page"},{"location":"fasta/","page":"FASTA","title":"FASTA","text":"FASTA is a text-based file format for representing biological sequences. A FASTA file stores a list of sequence records with name, description, and sequence.","category":"page"},{"location":"fasta/","page":"FASTA","title":"FASTA","text":"The template of a sequence record is:","category":"page"},{"location":"fasta/","page":"FASTA","title":"FASTA","text":">{description}\n{sequence}","category":"page"},{"location":"fasta/","page":"FASTA","title":"FASTA","text":"Where the \"identifier\" is the first part of the description up to the first whitespace (or the entire description if there is no whitespace)","category":"page"},{"location":"fasta/","page":"FASTA","title":"FASTA","text":"Here is an example of a chromosomal sequence:","category":"page"},{"location":"fasta/","page":"FASTA","title":"FASTA","text":">chrI chromosome 1\nCCACACCACACCCACACACCCACACACCACACCACACACCACACCACACC\nCACACACACACATCCTAACACTACCCTAACACAGCCCTAATCTA","category":"page"},{"location":"fasta/#The-FASTARecord","page":"FASTA","title":"The FASTARecord","text":"","category":"section"},{"location":"fasta/","page":"FASTA","title":"FASTA","text":"FASTA records are, by design, very lax in what they can contain. They can contain almost arbitrary byte sequences, including invalid unicode, and trailing whitespace on their sequence lines, which will be interpreted as part of the sequence. If you want to have more certainty about the format, you can either check the content of the sequences with a regex, or (preferably), convert them to the desired BioSequence type.","category":"page"},{"location":"fasta/","page":"FASTA","title":"FASTA","text":"FASTA.Record","category":"page"},{"location":"fasta/#FASTX.FASTA.Record","page":"FASTA","title":"FASTX.FASTA.Record","text":"FASTA.Record\n\nMutable struct representing a FASTA record as parsed from a FASTA file. The content of the record can be queried with the following functions: identifier, description, sequence.\n\nFASTA records are un-typed, i.e. they are agnostic to what kind of data they contain.\n\nSee also: FASTA.Reader, FASTA.Writer\n\nExamples\n\njulia> rec = parse(FASTARecord, \">some header\\nTAqA\\nCC\");\n\njulia> identifier(rec)\n\"some\"\n\njulia> description(rec)\n\"some header\"\n\njulia> sequence(rec)\n\"TAqACC\"\n\njulia> typeof(description(rec)) == typeof(sequence(rec)) <: AbstractString\ntrue\n\n\n\n\n\n","category":"type"},{"location":"fasta/#FASTAReader-and-FASTAWriter","page":"FASTA","title":"FASTAReader and FASTAWriter","text":"","category":"section"},{"location":"fasta/","page":"FASTA","title":"FASTA","text":"FASTAWriter can optionally be passed the keyword width to control the line width. If this is zero or negative, it will write all record sequences on a single line. Else, it will wrap lines to the given maximal width.","category":"page"},{"location":"fasta/#Reference:","page":"FASTA","title":"Reference:","text":"","category":"section"},{"location":"fasta/","page":"FASTA","title":"FASTA","text":"FASTA.Reader\nFASTA.Writer\nvalidate_fasta","category":"page"},{"location":"fasta/#FASTX.FASTA.Reader","page":"FASTA","title":"FASTX.FASTA.Reader","text":"FASTA.Reader(input::IO; index=nothing, copy::Bool=true)\n\nCreate a buffered data reader of the FASTA file format. The reader is a BioGenerics.IO.AbstractReader, a stateful iterator of FASTA.Record. Readers take ownership of the underlying IO. Mutating or closing the underlying IO not using the reader is undefined behaviour. Closing the Reader also closes the underlying IO.\n\nSee more examples in the FASTX documentation.\n\nSee also: FASTA.Record, FASTA.Writer\n\nArguments\n\ninput: data source\nindex: Optional random access index (currently fai is supported). index can be nothing, a FASTA.Index, or an IO in which case an index will be parsed from the IO, or AbstractString, in which case it will be treated as a path to a fai file.\ncopy::Bool: iterating returns fresh copies instead of the same Record. Set to false for improved performance, but be wary that iterating mutates records.\n\nExamples\n\njulia> rdr = FASTAReader(IOBuffer(\">header\\nTAG\\n>another\\nAGA\"));\n\njulia> records = collect(rdr); close(rdr);\n\njulia> foreach(println, map(identifier, records))\nheader\nanother\n\njulia> foreach(println, map(sequence, records))\nTAG\nAGA\n\n\n\n\n\n","category":"type"},{"location":"fasta/#FASTX.FASTA.Writer","page":"FASTA","title":"FASTX.FASTA.Writer","text":"FASTA.Writer(output::IO; width=70)\n\nCreate a data writer of the FASTA file format. The writer is a BioGenerics.IO.AbstractWriter. Writers take ownership of the underlying IO. Mutating or closing the underlying IO not using the writer is undefined behaviour. Closing the writer also closes the underlying IO.\n\nSee more examples in the FASTX documentation.\n\nSee also: FASTA.Record, FASTA.Reader\n\nArguments\n\noutput: Data sink to write to\nwidth: Wrapping width of sequence characters. If < 1, no wrapping.\n\nExamples\n\njulia> FASTA.Writer(open(\"some_file.fna\", \"w\")) do writer\n    write(writer, record) # a FASTA.Record\nend\n\n\n\n\n\n","category":"type"},{"location":"fasta/#FASTX.FASTA.validate_fasta","page":"FASTA","title":"FASTX.FASTA.validate_fasta","text":"validate_fasta(io::IO) >: Nothing\n\nCheck if io is a valid FASTA file. Return nothing if it is, and an instance of another type if not.\n\nExamples\n\njulia> validate_fasta(IOBuffer(\">a bc\\nTAG\\nTA\")) === nothing\ntrue\n\njulia> validate_fasta(IOBuffer(\">a bc\\nT>G\\nTA\")) === nothing\nfalse\n\n\n\n\n\n","category":"function"},{"location":"files/","page":"File I/O","title":"File I/O","text":"CurrentModule = FASTX\nDocTestSetup = quote\n    using FASTX\nend","category":"page"},{"location":"files/#FASTX-formatted-files","page":"File I/O","title":"FASTX formatted files","text":"","category":"section"},{"location":"files/#Validate-files","page":"File I/O","title":"Validate files","text":"","category":"section"},{"location":"files/","page":"File I/O","title":"File I/O","text":"The functions validate_fasta and validate_fastq can be used to check if an IO contains data that can be read as FASTX. They return nothing if the IO is correctly formatted, and another value if not.","category":"page"},{"location":"files/","page":"File I/O","title":"File I/O","text":"They are significantly faster than parsing the whole file into records, and are memory efficient. Be aware that the validators mutate the IO by reading it, so make sure to reset the IO before using it to parse FASTX files.","category":"page"},{"location":"files/","page":"File I/O","title":"File I/O","text":"julia> io = IOBuffer(\">header\\r\\nAGG\\nKK\");\n\njulia> validate_fasta(io) === nothing\ntrue\n\njulia> read(io) # NB: IO is now exhausted\nUInt8[]\n\njulia> validate_fastq(IOBuffer(\"@header\\nTTT\\n+\\njkm\")) === nothing\ntrue","category":"page"},{"location":"files/#Readers-and-writers","page":"File I/O","title":"Readers and writers","text":"","category":"section"},{"location":"files/","page":"File I/O","title":"File I/O","text":"A Reader and a Writer are structs that wrap an IO, and allows efficient reading/writing of FASTX Records. For FASTA, use FASTA.Reader and FASTA.Writer, and for FASTQ - well I'm sure you've guessed it.","category":"page"},{"location":"files/","page":"File I/O","title":"File I/O","text":"Readers and writers take control over the underlying IO, and manipulating the IO underneath a Reader/Writer, e.g. by flushing or closing it, cause them to behave in an undefined manner.","category":"page"},{"location":"files/","page":"File I/O","title":"File I/O","text":"Closing readers/writers closes the underlying IO. Because they carry their own buffers, it's important to remember to close writers in particular, else the results may not be fully written to the file.","category":"page"},{"location":"files/","page":"File I/O","title":"File I/O","text":"Readers are iterables of Record:","category":"page"},{"location":"files/","page":"File I/O","title":"File I/O","text":"julia> reader = FASTAReader(IOBuffer(\">A\\nTAG\\n>B\\nAGA\"));\n\njulia> record = first(reader); typeof(record) == FASTA.Record\ntrue\n\njulia> sequence(record)\n\"TAG\"\n\njulia> # NB! Readers are mutable iterators as can be seen here:\n\njulia> sequence(first(reader))\n\"AGA\"\n\njulia> iterate(reader) === nothing # now empty\ntrue\n\njulia> close(reader)","category":"page"},{"location":"files/","page":"File I/O","title":"File I/O","text":"They are normally more than fast enough as they are. To squeeze extra performance out, you can pass the keyword copy=false. This will cause the reader to return the same record over and over, and mutate it into place.","category":"page"},{"location":"files/","page":"File I/O","title":"File I/O","text":"julia> reader = FASTAReader(IOBuffer(\">A\\nTAG\\n>B\\nAGA\"); copy=false);\n\njulia> rec1 = first(reader); sequence(rec1)\n\"TAG\"\n\njulia> rec2 = first(reader); sequence(rec2)\n\"AGA\"\n\njulia> rec1 === rec2\ntrue\n\njulia> sequence(rec1)\n\"AGA\"\n\njulia> close(reader)","category":"page"},{"location":"files/","page":"File I/O","title":"File I/O","text":"When using readers and writers, be careful that they carry their own buffer, meaning that the underlying IO may not be updated immediately after reading/writing:","category":"page"},{"location":"files/","page":"File I/O","title":"File I/O","text":"julia> io = IOBuffer();\n\njulia> writer = FASTAWriter(io);\n\njulia> write(writer, parse(FASTARecord, \">ABC\\nDEF\"));\n\njulia> take!(io) # NB: Empty!\nUInt8[]","category":"page"},{"location":"files/","page":"File I/O","title":"File I/O","text":"To use it correctly, either call flush, or close the writer first (which also closes the underlying stream). It is recommended to use readers and writers to do syntax in the form:","category":"page"},{"location":"files/","page":"File I/O","title":"File I/O","text":"FASTAWriter(open(my_path, \"w\")) do writer\n    for record in my_records\n        write(writer, record)\n    end\nend","category":"page"},{"location":"files/","page":"File I/O","title":"File I/O","text":"Which will work for most underlying IO types, and will close the writer when the function returns (hence also closing the underlying IO).","category":"page"},{"location":"files/","page":"File I/O","title":"File I/O","text":"Alternatively, the following syntax may be used:","category":"page"},{"location":"files/","page":"File I/O","title":"File I/O","text":"open(FASTAWriter, my_path) do writer\n    for record in my_records\n        write(writer, record)\n    end\nend","category":"page"},{"location":"records/","page":"Records","title":"Records","text":"CurrentModule = FASTX\nDocTestSetup = quote\n    using FASTX\nend","category":"page"},{"location":"records/#Records","page":"Records","title":"Records","text":"","category":"section"},{"location":"records/","page":"Records","title":"Records","text":"FASTX files are considered a sequence of Records, FASTA.Record for FASTA files and FASTQ.Record for FASTQ. For convenience, FASTARecord and FASTQRecord are aliases of FASTA.Record and FASTQ.Record.","category":"page"},{"location":"records/","page":"Records","title":"Records","text":"A Record object represent the text of the FASTX record as it is, e.g the following FASTA record:","category":"page"},{"location":"records/","page":"Records","title":"Records","text":">some header here\nTAGATGAA\nAA","category":"page"},{"location":"records/","page":"Records","title":"Records","text":"Is stored in a FASTA.Record object roughly as its constituent bytes, plus some metadata. There is no notion in the record object of being a DNA or RNA sequence - it's simply a bytearray.","category":"page"},{"location":"records/","page":"Records","title":"Records","text":"Records can be constructed from raw parts (i.e. description and sequence and, for FASTQ, quality), where","category":"page"},{"location":"records/","page":"Records","title":"Records","text":"description::AbstractString\nsequence::Union{AbstractString, BioSequence}\nquality::Union{AbstractString, Vector{<:Number}}","category":"page"},{"location":"records/","page":"Records","title":"Records","text":"Alternatively, they can be parsed directly from a string or an AbstractVector{UInt8}.","category":"page"},{"location":"records/","page":"Records","title":"Records","text":"julia> record = parse(FASTARecord, \">abc\\nAGCC\\nCCGA\");\n\njulia> record2 = FASTARecord(\"abc\", \"AGCCCCGA\");\n\njulia> record == record2\ntrue","category":"page"},{"location":"records/","page":"Records","title":"Records","text":"Records can be queried for their information, namely identifier, description and sequence (and quality, for FASTQ). By default, this returns an AbstractString view into the Record's data:","category":"page"},{"location":"records/","page":"Records","title":"Records","text":"julia> record = parse(FASTARecord, \">ident desc\\nUGU\\nGA\");\n\njulia> (identifier(record), description(record), sequence(record))\n(\"ident\", \"ident desc\", \"UGUGA\")","category":"page"},{"location":"records/","page":"Records","title":"Records","text":"However, you can ask for getting the sequences as a String or any subtype of BioSequence:","category":"page"},{"location":"records/","page":"Records","title":"Records","text":"julia> record = parse(FASTARecord, \">abc\\nUGC\\nCCA\");\n\njulia> using BioSequences # LongRNA defined in BioSequences.jl\n\njulia> sequence(LongRNA{2}, record)\n6nt RNA Sequence:\nUGCCCA\n\njulia> sequence(String, record)\n\"UGCCCA\"","category":"page"},{"location":"records/","page":"Records","title":"Records","text":"The number of bytes in the sequence of a Record can be queried using seqsize:","category":"page"},{"location":"records/","page":"Records","title":"Records","text":"julia> record = parse(FASTARecord, \">abc\\nUGC\\nCCA\");\n\njulia> seqsize(record)\n6","category":"page"},{"location":"records/#Reference:","page":"Records","title":"Reference:","text":"","category":"section"},{"location":"records/","page":"Records","title":"Records","text":"identifier\ndescription\nsequence\nseqsize","category":"page"},{"location":"records/#FASTX.identifier","page":"Records","title":"FASTX.identifier","text":"identifier(record::Record)::AbstractString\n\nGet the sequence identifier of record. The identifier is the description before any whitespace. If the identifier is missing, return an empty string. Returns an AbstractString view into the record. If the record is overwritten, the string data will be corrupted.\n\nSee also: description, sequence\n\nExamples\n\njulia> record = parse(FASTA.Record, \">ident_here some descr \\nTAGA\");\n\njulia> identifier(record)\n\"ident_here\"\n\n\n\n\n\n","category":"function"},{"location":"records/#FASTX.description","page":"Records","title":"FASTX.description","text":"description(record::Record)::AbstractString\n\nGet the description of record. The description is the entire header line, minus the leading > or @ symbols for FASTA/FASTQ records, respectively, including trailing whitespace. Returns an AbstractString view into the record. If the record is overwritten, the string data will be corrupted.\n\nSee also: identifier, sequence\n\nExamples\n\njulia> record = parse(FASTA.Record, \">ident_here some descr \\nTAGA\");\n\njulia> description(record)\n\"ident_here some descr \"\n\n\n\n\n\n","category":"function"},{"location":"records/#FASTX.sequence","page":"Records","title":"FASTX.sequence","text":"sequence([::Type{S}], record::Record, [part::UnitRange{Int}])::S\n\nGet the sequence of record.\n\nS can be either a subtype of BioSequences.BioSequence, AbstractString or String. If elided, S defaults to an AbstractString subtype. If part argument is given, it returns the specified part of the sequence.\n\nSee also: identifier, description\n\nExamples\n\njulia> record = parse(FASTQ.Record, \"@read1\\nTAGA\\n+\\n;;]]\");\n\njulia> sequence(record)\n\"TAGA\"\n\njulia> sequence(LongDNA{2}, record)\n4nt DNA Sequence:\nTAGA\n\n\n\n\n\n","category":"function"},{"location":"records/#FASTX.seqsize","page":"Records","title":"FASTX.seqsize","text":"seqsize(::Record)::Int\n\nGet the number of bytes in the sequence of a Record. Note that in the presence of non-ASCII characters, this may differ from length(sequence(record)).\n\nSee also: sequence\n\nExamples\n\njulia> seqsize(parse(FASTA.Record, \">hdr\\nKRRLPW\\nYHS\"))\n9\n\njulia> seqsize(parse(FASTA.Record, \">hdr\\nαβγδϵ\"))\n10\n\n\n\n\n\n","category":"function"},{"location":"","page":"Overview","title":"Overview","text":"CurrentModule = FASTX\nDocTestSetup = quote\n    using FASTX, BioSequences\nend","category":"page"},{"location":"#FASTX","page":"Overview","title":"FASTX","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"(Image: Latest Release) (Image: MIT license)  (Image: DOI) (Image: Pkg Status) (Image: Chat)","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"Read and write files in FASTA and FASTQ format, the most common biological sequence file format.","category":"page"},{"location":"#Installation","page":"Overview","title":"Installation","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"You can install FASTX from the julia REPL. Press ] to enter pkg mode again, and enter the following:","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"(v1.8) pkg> add FASTX","category":"page"},{"location":"#Quickstart","page":"Overview","title":"Quickstart","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"\"FASTX\" is a shorthand for the two related formats FASTA and FASTQ, which are handled by the two modules FASTX.FASTA and FASTX.FASTQ, respectively.","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"Construct records from raw parts","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"julia> record = FASTARecord(\"some header\", dna\"TAGAAGA\");\n\njulia> (identifier(record), description(record), sequence(record))\n(\"some\", \"some header\", \"TAGAAGA\")\n\njulia> sequence(LongDNA{2}, record)\n7nt DNA Sequence:\nTAGAAGA","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"Validate files","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"julia> validate_fasta(IOBuffer(\">ABC\\nDEF\")) === nothing\ntrue\n\njulia> validate_fastq(IOBuffer(\"@ABC\\nTAG\\n+\\nDDD\")) === nothing\ntrue","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"Read FASTX files","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"record = FASTAReader(first, IOBuffer(\">ABC\\nDEF\"))\n\nsequence(record) == \"DEF\" # should be true\n\n# Or with do-syntax\nFASTAReader(GzipDecompressorStream(open(path))) do reader\n    for record in reader\n        # do something with record\n    end\nend","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"Write FASTX files","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"FASTQWriter(open(path, \"w\")) do writer\n    for record in records\n        write(writer, record)\n    end\nend","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"See more details in the sections in the sidebar.","category":"page"},{"location":"#Contributing","page":"Overview","title":"Contributing","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"We appreciate contributions from users including reporting bugs, fixing issues, improving performance and adding new features.","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"Take a look at the contributing files detailed contributor and maintainer guidelines, and code of conduct.","category":"page"}]
}
